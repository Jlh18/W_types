\documentclass{article}
\usepackage[left=1in,right=1in,tmargin = 25mm,bmargin = 25mm]{geometry}
\usepackage[left=1in,right=1in]{geometry}
\usepackage{subfiles}
\usepackage{amsmath, amssymb, stmaryrd, verbatim, bbm, mathabx} % math symbols
\usepackage{amsthm} % thm environment
\usepackage{mdframed} % Customizable Boxes
\usepackage{hyperref,nameref,cleveref,enumitem} % for references, hyperlinks
\usepackage[dvipsnames]{xcolor} % Fancy Colours
\usepackage{mathrsfs} % Fancy font
\usepackage{tikz, tikz-cd, float} % Commutative Diagrams
\usepackage{perpage}
\usepackage{parskip} % So that paragraphs look nice
\usepackage{ifthen,xargs} % For defining better commands
\usepackage{anyfontsize}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{tgpagella}
\usepackage{titlesec}
\usepackage{url}
\usepackage{listings}

% % Set the monospace font
\usepackage{inconsolata}

% % Misc
\newcommand{\brkt}[1]{\left(#1\right)}
\newcommand{\sqbrkt}[1]{\left[#1\right]}
\newcommand{\dash}{\text{-}}
\newcommand{\tdt}{\times \dots \times}

% % Logic
\renewcommand{\implies}{\Rightarrow}
\renewcommand{\iff}{\Leftrightarrow}
\newcommand{\IFF}{\leftrightarrow}
\newcommand{\limplies}{\Leftarrow}
\newcommand{\NOT}{\neg\,}
\newcommand{\AND}{\land}
\newcommand{\OR}{\lor}
\newenvironment{forward}{($\implies$)}{}
\newenvironment{backward}{($\limplies$)}{}
% General way of making larger symbols with limits above and below
\makeatletter
\DeclareRobustCommand\bigop[1]{%
  \mathop{\vphantom{\sum}\mathpalette\bigop@{#1}}\slimits@
}
\newcommand{\bigop@}[2]{%
  \vcenter{%
    \sbox\z@{$#1\sum$}%
    \hbox{\resizebox{
      \ifx#1\displaystyle.7\fi\dimexpr\ht\z@+\dp\z@}{!}{$\m@th#2$}}% symbol size
  }%
}
\makeatother
\newcommand{\bigforall}[2]{\DOTSB\bigop{\forall}_{#1}^{#2}}
\newcommand{\bigexists}[2]{\DOTSB\bigop{\exists}_{#1}^{#2}}
\newcommand{\bigand}[2]{\DOTSB\bigop{\mbox{\Large$\land$}}_{#1}^{#2}}
\newcommand{\bigor}[2]{\DOTSB\bigop{\mbox{\Large$\lor$}}_{#1}^{#2}}

% % Sets
\DeclareMathOperator{\supp}{supp}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\st}{\,|\,}
\newcommand{\minus}{\setminus}
\newcommand{\subs}{\subseteq}
\newcommand{\ssubs}{\subsetneq}
\DeclareMathOperator{\im}{Im}
\newcommand{\nothing}{\varnothing}
\newcommand\res[2]{{% we make the whole thing an ordinary symbol
  \left.\kern-\nulldelimiterspace
  % automatically resize the bar with \right
  #1 % the function
  \vphantom{\big|}
  % pretend it's a little taller at normal size
  \right|_{#2} % this is the delimiter
  }}

% % Greek
\newcommand{\al}{\alpha}
\newcommand{\be}{\beta}
\newcommand{\ga}{\gamma}
\newcommand{\de}{\delta}
\newcommand{\ep}{\varepsilon}
\newcommand{\io}{\iota}
\newcommand{\ka}{\kappa}
\newcommand{\la}{\lambda}
\newcommand{\om}{\omega}
\newcommand{\si}{\sigma}

\newcommand{\Ga}{\Gamma}
\newcommand{\De}{\Delta}
\newcommand{\Th}{\Theta}
\newcommand{\La}{\Lambda}
\newcommand{\Si}{\Sigma}
\newcommand{\Om}{\Omega}

% % Mathbb
\newcommand{\A}{\mathbb{A}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\M}{\mathbb{M}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\V}{\mathbb{V}}
\newcommand{\U}{\mathbb{U}}

% % Mathcal
\renewcommand{\AA}{\mathcal{A}}
\newcommand{\BB}{\mathcal{B}}
\newcommand{\CC}{\mathcal{C}}
\newcommand{\DD}{\mathcal{D}}
\newcommand{\EE}{\mathcal{E}}
\newcommand{\FF}{\mathcal{F}}
\newcommand{\GG}{\mathcal{G}}
\newcommand{\HH}{\mathcal{H}}
\newcommand{\II}{\mathcal{I}}
\newcommand{\JJ}{\mathcal{J}}
\newcommand{\KK}{\mathcal{K}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\MM}{\mathcal{M}}
\newcommand{\NN}{\mathcal{N}}
\newcommand{\OO}{\mathcal{O}}
\newcommand{\PP}{\mathcal{P}}
\newcommand{\QQ}{\mathcal{Q}}
\newcommand{\RR}{\mathcal{R}}
\renewcommand{\SS}{\mathcal{S}}
\newcommand{\TT}{\mathcal{T}}
\newcommand{\UU}{\mathcal{U}}
\newcommand{\VV}{\mathcal{V}}
\newcommand{\WW}{\mathcal{W}}
\newcommand{\XX}{\mathcal{X}}
\newcommand{\YY}{\mathcal{Y}}
\newcommand{\ZZ}{\mathcal{Z}}

% % Mathfrak
\newcommand{\f}[1]{\mathfrak{#1}}

% % Mathrsfs
\newcommand{\s}[1]{\mathscr{#1}}

% % Category Theory
\newcommand{\obj}[1]{\mathrm{Obj}\left(#1\right)}
\newcommand{\Hom}[3]{\mathrm{Hom}_{#3}(#1, #2)\,}
\newcommand{\mor}[3]{\mathrm{Mor}_{#3}(#1, #2)\,}
\newcommand{\End}[2]{\mathrm{End}_{#2}#1\,}
\newcommand{\aut}[2]{\mathrm{Aut}_{#2}#1\,}
\newcommand{\CAT}{\mathbf{Cat}}
\newcommand{\SET}{\mathbf{Set}}
\newcommand{\TOP}{\mathbf{Top}}
%\newcommand{\GRP}{\mathbf{Grp}}
\newcommand{\RING}{\mathbf{Ring}}
\newcommand{\MOD}[1][R]{#1\text{-}\mathbf{Mod}}
\newcommand{\VEC}[1][K]{#1\text{-}\mathbf{Vec}}
\newcommand{\ALG}[1][R]{#1\text{-}\mathbf{Alg}}
\newcommand{\PSH}[1]{\mathbf{PSh}\brkt{#1}}
\newcommand{\map}[2]{ \yrightarrow[#2][2.5pt]{#1}[-1pt] }
\newcommand{\op}{^{op}}
\newcommand{\darrow}{\downarrow}
\newcommand{\LIM}[2]{\varprojlim_{#2}#1}
\newcommand{\COLIM}[2]{\varinjlim_{#2}#1}
\newcommand{\hookr}{\hookrightarrow}

% % Algebra
\newcommand{\iso}{\cong}
\newcommand{\nsub}{\trianglelefteq}
\newcommand{\id}[1]{\mathbbm{1}_{#1}}
\newcommand{\inv}{^{-1}}
\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\codom}{codom}
\DeclareMathOperator{\coker}{Coker}
\DeclareMathOperator{\spec}{Spec}

% % Analysis
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\norm}[1]{\left\Vert #1 \right\Vert}
\renewcommand{\bar}[1]{\overline{#1}}
\newcommand{\<}{\langle}
\renewcommand{\>}{\rangle}
\renewcommand{\check}[1]{\widecheck{#1}}

% % Galois
\newcommand{\Gal}[2]{\mathrm{Gal}_{#1}(#2)}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Stab}{Stab}
\newcommand{\emb}[3]{\mathrm{Emb}_{#1}(#2, #3)}
\newcommand{\Char}[1]{\mathrm{Char}#1}

% % Model Theory
\newcommand{\intp}[2]{
    \star_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\subintp}[3]{
    {#3}_{\text{\scalebox{0.7}{$#1$}}}^{
    \text{\scalebox{0.7}{$#2$}}}}
\newcommand{\modintp}[2]{#2^\text{\scalebox{0.7}{$#1$}}}
\newcommand{\mmintp}[1]{\modintp{\MM}{#1}}
\newcommand{\nnintp}[1]{\modintp{\NN}{#1}}
\DeclareMathOperator{\const}{constants}
\DeclareMathOperator{\func}{functions}
\DeclareMathOperator{\rel}{relations}
% \newcommand{\term}[1]{{#1}_\mathrm{ter}}
% \newcommand{\tv}[1]{\textrm{tv}_{#1}}
% \newcommand{\struc}[1]{\mathbf{Str}(#1)}
% \newcommand{\form}[1]{{#1}_\mathrm{for}}
% \newcommand{\var}[1]{{#1}_\mathrm{var}}
% \newcommand{\theory}[1]{{#1}_\mathrm{the}}
% \newcommand{\carrier}[1]{{#1}_\mathrm{car}}
% \newcommand{\model}[1]{\vDash_{#1}}
% \newcommand{\nodel}[1]{\nvDash_{#1}}
% \newcommand{\modelsi}{\model{\Si}}
% \newcommand{\nodelsi}{\nvDash_{\Si}}
% \newcommand{\eldiag}[2]{\mathrm{ElDiag}(#1,#2)}
% \newcommand{\atdiag}[2]{\mathrm{AtDiag}(#1,#2)}
% \newcommand{\Theory}{\mathrm{Th}}
% \newcommand{\unisen}[1]{{#1}_\mathrm{uni}}
\newcommand{\lift}[2]{\uparrow_{#1}^{#2}}
\newcommand{\fall}[2]{\downarrow_{#1}^{#2}}
\DeclareMathOperator{\GRP}{GRP}
\newcommand{\RNG}{\mathrm{RNG}}
\newcommand{\ER}{\mathrm{ER}}
\DeclareMathOperator{\FLD}{FLD}
\DeclareMathOperator{\ID}{ID}
\DeclareMathOperator{\ZFC}{ZFC}
\DeclareMathOperator{\ACF}{ACF}
\newcommand{\BLN}{\mathrm{BLN}}
\newcommand{\PO}{\mathrm{PO}}
\DeclareMathOperator{\tp}{tp}
\DeclareMathOperator{\qftp}{qftp}
\DeclareMathOperator{\qf}{qf}
\DeclareMathOperator{\eqzero}{eqzero}
\newcommand{\MR}[2]{\mathrm{MR}^{#1}(#2)}
\DeclareMathOperator{\MD}{MD}
\DeclareMathOperator{\acl}{acl}
\DeclareMathOperator{\cl}{cl}
\DeclareMathOperator{\mdeg}{m.deg}
\DeclareMathOperator{\kdim}{k.dim}
\newcommand{\Mod}[1]{EDITTHIS {#1}}
% % Set theory
\DeclareMathOperator{\ord}{Ord}

% % Boolean algebra
\newcommand{\NEG}{\smallsetminus}
\newcommand{\upa}[1]{#1^{\uparrow}}

% % Field theory
\DeclareMathOperator{\tdeg}{t.deg}
\newcommand{\zmo}[2][p]{\Z/#1^{#2}\Z}

%% code from mathabx.sty and mathabx.dcl to get some symbols from mathabx
\DeclareFontFamily{U}{mathx}{\hyphenchar\font45}
\DeclareFontShape{U}{mathx}{m}{n}{
      <5> <6> <7> <8> <9> <10>
      <10.95> <12> <14.4> <17.28> <20.74> <24.88>
      mathx10
      }{}
\DeclareSymbolFont{mathx}{U}{mathx}{m}{n}
\DeclareFontSubstitution{U}{mathx}{m}{n}
\DeclareMathAccent{\widecheck}{0}{mathx}{"71}

% Arrows with text above and below with adjustable displacement
% (Stolen from Stackexchange)
\newcommandx{\yaHelper}[2][1=\empty]{
\ifthenelse{\equal{#1}{\empty}}
  % no offset
  { \ensuremath{ \scriptstyle{ #2 } } }
  % with offset
  { \raisebox{ #1 }[0pt][0pt]{ \ensuremath{ \scriptstyle{ #2 } } } }
}

\newcommandx{\yrightarrow}[4][1=\empty, 2=\empty, 4=\empty, usedefault=@]{
  \ifthenelse{\equal{#2}{\empty}}
  % there's no text below
  { \xrightarrow{ \protect{ \yaHelper[ #4 ]{ #3 } } } }
  % there's text below
  {
    \xrightarrow[ \protect{ \yaHelper[ #2 ]{ #1 } } ]
    { \protect{ \yaHelper[ #4 ]{ #3 } } }
  }
}

% xcolor
\definecolor{darkgrey}{gray}{0.10}
\definecolor{lightgrey}{gray}{0.30}
\definecolor{slightgrey}{gray}{0.80}
\definecolor{softblue}{RGB}{30,100,200}

% hyperref
\hypersetup{
      colorlinks = true,
      linkcolor = {softblue},
      citecolor = {blue}
}

\newcommand{\link}[1]{\hypertarget{#1}{}}
\newcommand{\linkto}[2]{\hyperlink{#1}{#2}}

% Theorems

% % custom theoremstyles
\newtheoremstyle{definitionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % custom theoremstyles
\newtheoremstyle{propositionstyle}
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\bf}% head font
{\vspace{1mm}}% punctuation between head and body
{\newline}% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

\newtheoremstyle{exercisestyle}%
{0pt}% above thm
{0pt}% below thm
{\it}% body font
{}% space to indent
{\scshape}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{ (#3)}}

\newtheoremstyle{remarkstyle}%
{0pt}% above thm
{0pt}% below thm
{}% body font
{}% space to indent
{\it}% head font
{.}% punctuation between head and body
{ }% space after head
{\thmname{#1}\thmnote{\,\,--\,\,#3}}

% % Theorem environments

\theoremstyle{definitionstyle}
\newmdtheoremenv[
    %skipabove = \baselineskip
    linewidth = 2pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{dfn}{Definition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{prop}{Proposition}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{cor}{Corollary}
\newmdtheoremenv[
    linewidth = 2 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{lem}{Lemma}


\theoremstyle{exercisestyle}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{ex}{Exercise}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{eg}{Example}
\newmdtheoremenv[
    linewidth = 0.7 pt,
    leftmargin = 20pt,
    rightmargin = 0pt,
    linecolor = darkgrey,
    topline = false,
    bottomline = false,
    rightline = false,
    footnoteinside = true
]{nttn}{Notation}

\theoremstyle{remarkstyle}
\newtheorem{rmk}{Remark}

% % footnotes
\renewcommand{\thempfootnote}{$\dagger$}
\MakePerPage{footnote}

% % tikzcd diagram
\newenvironment{cd}{
    \begin{figure}[H]
    \centering
    \begin{tikzcd}
}{
    \end{tikzcd}
    \end{figure}
}

% tikzcd
% % Substituting symbols for arrows in tikz comm-diagrams.
\tikzset{
  symbol/.style={
    draw=none,
    every to/.append style={
      edge node={node [sloped, allow upside down, auto=false]{$#1$}}}
  }
}


\titlespacing*{\section}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}
\titlespacing*{\subsection}
{0pt}{5ex plus 1ex minus .2ex}{4ex plus .2ex}

% Syntax highlighting for lean

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.6, 0.3, 0.6}   % light purple
\definecolor{tacticcolor}{rgb}{0.2, 0.2, 0.6}    % dark purple
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.7, 0.2, 0.2}    % blue
\definecolor{sortcolor}{rgb}{0.2, 0.7, 0.7}      % cyan
\definecolor{attributecolor}{RGB}{120,0,0}       % maroon
\definecolor{draculaGrey}{RGB}{25, 27, 15}       % grey

\def\lstlanguagefiles{lstlean.tex}
% set default language
\lstset{language=lean}

\begin{document}
\title{W-Types and Initial Algebras via Examples}
\author{Joseph Hua}
\maketitle

\section{Introduction}

W-types offer a compact method of presenting tree-like inductive types.
We introduce this via the two standard examples: the naturals and lists.
The idea is to break down an inductive type into two pieces of data,
its constructors and their arities,
so that each way of making something in the inductive type looks like
$\texttt{the\_type}^{n} \to \texttt{the\_type}$.

Types such as binary sums and products have simple categorical descriptions
via their universal properties.
The benefit of viewing inductive types as W-types is that it offers a
categorical description of the type as an initial algebra of some endofunctor
- for example allowing us to generalise the notion of the naturals to having a
natural numbers object or a list object in a category (with certain (co)limits).
There are also practical applications;
W-type constructions should be useful for computing the cardinalities
of inductively defined types.
In particular I should be able to compute the cardinality of
the type of \texttt{terms} in a model-theoretic language by
constructing a corresponding W-type, and
Chris Hughes has used them for computing the cardinalities of polynomial rings.

My work is across 3 files, though only two of them should be considered
original work, as \texttt{endofunctor.algebra} is mostly a refactoring
of \texttt{category\_theory/monad/algebra} in the library
(except where I show that initial algebras are preserved by their endofunctors).
The two examples of W-types make up the file \texttt{constructions} and
everything else (things about polynomial endofunctors for W-types)
is in \texttt{endofunctor.W}.

\section{W-types as inductive types}

We adopt the notational convention from mathlib, where
we use $\al$ to denote the type indexing the constructors,
and $\be$ to denote the type for the arities.
Given such a pair, one gets a W-type by the following definition:

\begin{lstlisting}
inductive W_type {α : Type*} (β : α → Type*)
| mk (a : α) (f : β a → W_type) : W_type \end{lstlisting}

This says, to make a term in the W-type, it suffices to
give a constructor \texttt{a} and a map \texttt{f} from the arity to the type.
Since the arity will in our cases be small finite types,
the map amounts to picking a finite number of terms in the type.

We break down the naturals into its constructors and their arities.
The naturals have two constructors \texttt{nat.zero} and \texttt{nat.succ},
where \texttt{nat.zero} has empty arity (nullary) $\N^{0} \to \N$
and \texttt{nat.succ} has unit arity (unary) $\N^{1} \to \N$.
This is because to come up with a natural, we either give the
constructor \texttt{nat.zero} and nothing else, or give \texttt{nat.succ}
and a natural $n$.

\begin{lstlisting}
/-- The constructors for the naturals -/
inductive nat_α : Type
| zero : nat_α
| succ : nat_α

/-- The arity of the constructors for the naturals, `zero` takes no arguments, `succ` takes one -/
def nat_β : nat_α → Type
| nat_α.zero := empty
| nat_α.succ := unit\end{lstlisting}

Now, \texttt{W\_type nat\_$\be$} should look exactly like $\N$.
To make \texttt{nat.zero} we pick the constructor \texttt{nat\_$\al$.zero}
and provide nothing (in the form of the unique map out of the empty type).
To make \texttt{nat.succ n} we pick the constructor \texttt{nat\_$\al$.succ}
and provide the previous term from the W-type corresponding to $n$.

\begin{lstlisting}
/-- The isomorphism from the naturals to its corresponding `W_type` -/
def nat_to : ℕ → W_type nat_β
| nat.zero := ⟨ nat_α.zero , empty.elim ⟩
| (nat.succ n) := ⟨ nat_α.succ , λ _ , nat_to n ⟩

/-- The isomorphism from the `W_type` of the naturals to the naturals -/
def to_nat : W_type nat_β → ℕ
| (W_type.mk nat_α.zero f) := 0
| (W_type.mk nat_α.succ f) := (to_nat (f ())).succ \end{lstlisting}

It follows that these give an equivalence between the types.
Lists are viewed slightly differently to usual with \texttt{list $\ga$}
having \texttt{1 + $\ga$} many constructors instead of just two:
\texttt{list.nil} has empty arity
\texttt{$($list $\ga)^{0} \to $ list $\ga$}
and for each $x : \ga$
\texttt{list.cons a} is a constructor with unit arity
\texttt{$($list $\ga)^{1} \to $ list $\ga$}.
To make a list we either give the constructor \texttt{list.nil} and nothing else,
or give \texttt{list.cons a} with a list \texttt{l}.

\begin{lstlisting}
/-- The constructors for lists -/
inductive list_α : Type u
| nil : list_α
| cons : γ → list_α

/-- The arities of each constructor for lists, `nil` takes no arguments, `cons hd` takes one -/
def list_β : list_α γ → Type u
| list_α.nil := pempty
| (list_α.cons hd) := punit \end{lstlisting}

Then we can see that to construct a list,
the empty list corresponds to giving the
constructor \texttt{list\_$\al$.nil} and nothing else,
whilst appending a new value at the head of the list corresponds to
giving the constructor \texttt{list\_$\al$.cons hd} and the
list corresponding to the previous list.

\begin{lstlisting}
/-- The isomorphism from lists to W_types -/
@[simp] def list_to_W_type : list γ → W_type (list_β γ)
| list.nil := ⟨ list_α.nil, pempty.elim ⟩
| (list.cons hd tl) := ⟨ list_α.cons hd, λ _ , list_to_W_type tl ⟩

/-- The isomorphism from W_types to lists -/
@[simp] def W_type_to_list : W_type (list_β γ) → list γ
| (W_type.mk list_α.nil f) := []
| (W_type.mk (list_α.cons hd) f) := hd :: W_type_to_list (f punit.star) \end{lstlisting}

The equivalence between \texttt{W\_type (list\_$\be$ $\ga$)}
and \texttt{list $\ga$} follows from these definitions.

W-types as described above don't cover everything that one can make using
\texttt{inductive} in lean.
Inductive families such as \texttt{dvector} which takes a natural
to lists of length $n$ in a type $\al$ cannot be described exactly.
(The following definitions are both from the \href{https://github.com/flypitch/flypitch}{flypitch} project.)

\begin{lstlisting}
inductive dvector (α : Type u) : ℕ → Type u
| nil : dvector 0
| cons : ∀{n} (x : α) (xs : dvector n), dvector (n+1) \end{lstlisting}

Another example would be

\begin{lstlisting}
/-- Preterms are used in model theory to define terms in a language -/
inductive preterm : ℕ → Type u
| var : ∀ (k : ℕ), preterm 0
| func : ∀ {l : ℕ} (f : func_symb l), preterm l
| app : ∀ {l : ℕ} (t : preterm (l + 1)) (s : preterm 0), preterm l \end{lstlisting}

The above are both problematic because the types of the constructors
depend on some $n : \N$, so that they're not of the form
\texttt{the\_type$^{n} \to $ the\_type} like before.
There are then \textit{indexed W-types} designed for these purposes,
and reducing indexed W-types to standard W-types is an active area of research.
See \href{https://cs.ioc.ee/types15/slides/sattler-slides.pdf}{here}.

\section{Natural numbers objects}

The categorical way of viewing the naturals is as a natural number object
in the category \texttt{Type}.
A natural number object is defined to be the initial algebra of the polynomial
endofunctor $1 + X$:

\begin{align*}
  1 + X : \texttt{Type} & \to \texttt{Type} \\
            \al & \mapsto \texttt{punit} \sqcup \al
\end{align*}

Then an algebra of this endofunctor is an object \texttt{c : Type}
with a `structure map` \texttt{str : 1 + c $\to$ c}.

\begin{lstlisting}
/-- An algebra of an endofunctor; `str` stands for "structure morphism" -/
structure algebra (F : C ⥤ C) :=
(A : C)
(str : F.obj A ⟶ A)\end{lstlisting}

The naturals are an algebra of $1 + X$,
with the map from $1 + \N$ mapping to \texttt{nat.zero} on the left
and taking \texttt{n} to \texttt{nat.succ n} on the right.
The data of an algebra of $1 + X$ can be represented using the following diagram.

\begin{cd}
  1 & c & c
	\arrow["z", from=1-1, to=1-2]
	\arrow["s", from=1-2, to=1-3]
\end{cd}

The algebras of an endofunctor form a category,
with morphisms in between them maps between the underlying objects
that commute with the structure map. \footnote{
  The \texttt{ext} attribute provides the tactic \texttt{ext}
  with a lemma for showing when two such morphisms are equal.
  Here it reduces equality to equality of the underlying morphisms in
  the category \texttt{C}.
}

\begin{lstlisting}
/-- A morphism between algebras of endofunctor `F` -/
@[ext] structure hom (A₀ A₁ : algebra F) :=
(f : A₀.1 ⟶ A₁.1)
(h' : F.map f ≫ A₁.str = A₀.str ≫ f . obviously)\end{lstlisting}

\begin{cd}
	1 & \N & \N \\
	1 & c & c
	\arrow["z", from=2-1, to=2-2]
	\arrow["s", from=2-2, to=2-3]
	\arrow["{\texttt{zero}}", from=1-1, to=1-2]
	\arrow["{\texttt{succ}}", from=1-2, to=1-3]
	\arrow[dashed, from=1-2, to=2-2]
	\arrow[dashed, from=1-3, to=2-3]
	\arrow["{===}"{marking}, draw=none, from=1-1, to=2-1]
\end{cd}

In this project we will \textit{not} define the general notion
polynomial endofunctors on a category with pullbacks,
but rather treat a polynomial endofunctor as any functor (isomorphic to one) of the form
\[ \Sigma_{a : A} X^{B a} : \texttt{Type} \to \texttt{Type}\]
Then for each W-type we construct such a polynomial endofunctor and show
that the W-type is the initial algebra of the endofunctor, meaning
it is the initial object in the category of algebras.

\section{Inital algebras as objects preserved by their endofunctors}

Before we prove the main results we study an important property of initial
algebras. An intuitive view of initial algebras offered by
\href{https://www.youtube.com/watch?v=zkDVCQiveEo}{Bartosz Milewski}
is that they are the (smallest)
objects that are preserved when one recursively applies
the associated polynomial endofunctor.
Specialising to W-types (which we will show to be initial algebras),
this is viewing the inductive type as being
freely generated by its constructors.
For example this says that
``the only way to make a natural is by using \texttt{zero} or \texttt{succ}''.

Note that the initial algebra is not in general the only object preserved by
the endofunctor. For example $1 + X$ preserves the type $\R$
(types in bijection are equivalent),
which certainly is not isomorphic to $\N$ as a type, since they do not biject.
The proof that initial algebras are preserved comes from considering this diagram:

\begin{cd}
  {F A} & FFA & FA \\
	A & FA & A
	\arrow["{F\texttt{str}}", from=1-2, to=2-2]
	\arrow["{\texttt{str}}", from=1-3, to=2-3]
	\arrow["{\texttt{str}}"', from=2-2, to=2-3]
	\arrow["{F \texttt{str}}", from=1-2, to=1-3]
	\arrow["{F g}", dashed, from=1-1, to=1-2]
	\arrow["g"', dashed, from=2-1, to=2-2]
	\arrow["{\texttt{str}}", from=1-1, to=2-1]
\end{cd}

Naturally, it is the structure map that is the isomorphism
from the image $F A$ to the initial algebra $A$.
The inverse of the structure map is $g$,
which comes from the universal property of the initial algebra $A$,
noting that $F A$ is another algebra of $F$.
Applying uniqueness from the universal property of $A$
(\texttt{is\_initial.hom\_ext})
we see that the composition along the bottom is the identity.
The inverse $g$ is given by \texttt{str\_inv}

\begin{lstlisting}
variables {A} (h : limits.is_initial A)

/-- The inverse of the structure map of an initial algebra -/
def str_inv : A.1 ⟶ F.obj A.1 := (h.to ⟨ F.obj A.1 , F.map A.str ⟩).1

/- The composition along the bottom row is the identity (as an algebra morphism) -/
lemma left_inv' : (⟨str_inv h ≫ A.str⟩ : A ⟶ A) = 𝟙 A :=
limits.is_initial.hom_ext h _ (𝟙 A) \end{lstlisting}

We can forget this into the underlying category \texttt{Type}.

\begin{lstlisting}
lemma left_inv : str_inv h ≫ A.str = 𝟙 _ := congr_arg hom.f (left_inv' h) \end{lstlisting}
Since the above diagram commutes, we see that the other direction follows
\[ g \circ \texttt{str} = F (\texttt{g $\circ$ str}) = F \id{} \]

\begin{lstlisting}
lemma right_inv : A.str ≫ str_inv h = 𝟙 _ :=
by { rw [str_inv, ← (h.to ⟨ F.obj A.1 , F.map A.str ⟩).h,
  ← F.map_id, ← F.map_comp], congr, exact (left_inv h) } \end{lstlisting}

\section{W-types as initial algebras of their polynomial endofunctors}

Mathlib contains the result that for any W-type \texttt{W\_type $\be$},
\begin{lstlisting}
    W_type β ≃ Σ (a : α), β a → W_type β \end{lstlisting}
This is the obvious realization that
that W-types are closed under the constructor operation:
to make something on either side is just to give a pair $a : \al$ and
$b : \be a \to \texttt{W\_type } \be$.

Notice that the right hand side looks like a polynomial endofunctor
applied to \texttt{W\_type} $\be$.
Knowing from the previous section that initial algebras are
preserved by their functors, we might guess this is the right
polynomial endofunctor to consider. Indeed,

\begin{lstlisting}
/-- The polynomial endofunctor associated to a `W_type` -/
def polynomial_endofunctor : Type (max u₀ u₁) ⥤ Type (max u₀ u₁) :=
{ obj := λ X, Σ (a : α), β a → X,
  map := λ X Y f p, ⟨ p.1 , f ∘ p.2 ⟩ } \end{lstlisting}

Functoriality is simply the composition:
if I have $\be a$ many terms in $X$ and I apply $f : X \to Y$ to each of them,
then I obtain $\be a$ many terms in $Y$.

We can then make the W-type into an algebra over this polynomial endofunctor,
naturally using the equivalence above for the structure map
\begin{lstlisting}
def as_algebra : algebra (polynomial_endofunctor β) :=
{ A   := W_type β,
  str := W_type.of_sigma } \end{lstlisting}

To show that this is the initial algebra we simply need to show that
for any other algebra $A$ we have a unique algebra map from this into $A$.
This map should be defined by induction on the W-type:
to map \texttt{W\_type.mk a b} into $A$ we reconstruct it using the
structure map of $A$ (and the inductively given image of \texttt{b}):

\begin{lstlisting}
variables {β} (A : algebra (polynomial_endofunctor β))

/-- The map in `Type` from the initial algebra `W_type` to any other algebra -/
def lift_f : W_type β → A.A
| (W_type.mk a b) := A.str ⟨ a , λ x, lift_f (b x) ⟩

/-- The map in `endofunctor.algebra` from the initial algebra `W_type` to any other algebra -/
def lift : as_algebra β ⟶ A := { f := lift_f A } \end{lstlisting}

The uniqueness of this map is also proven by induction:

\begin{lstlisting}
lemma lift_uniq (f : as_algebra β ⟶ A) : f = lift A :=
begin
  ext w,
  induction w with a b hw,
  simp only [lift, lift_f],
  convert (congr_fun f.2 ⟨ a , b ⟩).symm,
  funext x,
  exact (hw x).symm,
end \end{lstlisting}

\begin{proof}
  (In words.) We supplied algebra morphisms with the \texttt{ext} attribute,
so we simply need to compare the underlying functions in \texttt{Type}.
This tactic also applies functional extensionality with a given term
$w : \texttt{W\_type } \be$,
so we are showing that the functions are equal on points.
We induct on $w$ so that we can definitionally reduce the inductively defined
\texttt{lift\_f} and use the induction hypothesis.
At this point the goal is to show that ``down right'' in the below diagrams
are equal (the diagrams commute by \texttt{lift} and \texttt{f} being algebra
morphisms).

\begin{cd}
  {P \texttt{ W\_type}} & {P A} && {P \texttt{ W\_type}} & {P A} \\
	{\texttt{W\_type}} & A && {\texttt{W\_type}} & A
	\arrow["{\texttt{str}}"', from=1-1, to=2-1]
	\arrow["{P\texttt{ lift}}", from=1-1, to=1-2]
	\arrow["{\texttt{str}}", from=1-2, to=2-2]
	\arrow["{\texttt{lift}}"', from=2-1, to=2-2]
	\arrow["{P f}", from=1-4, to=1-5]
	\arrow["{\texttt{str}}", from=1-5, to=2-5]
	\arrow["{\texttt{str}}"', from=1-4, to=2-4]
	\arrow["f"', from=2-4, to=2-5]
\end{cd}

Hence it suffices that ``right down'' in the diagrams commute,
which follows from the induction hypothesis.
\end{proof}

\section{Computing polynomials}

We conclude by showing that the polynomial endofunctors
associated to $\N$ and \texttt{list} $\gamma$ are naturally isomorphic to
$1 + X$ and $1 + \gamma X$.
In order to do so we make a category of polynomial endofunctors
(of this particular form) \texttt{W\_type.cat},
as a full subcategory of the functor category \texttt{Type $\to$ Type}
(strictly speaking the objects are pairs $\al , \be$ rather than endofunctors,
and their image under talking \texttt{polynomial\_endofunctor}
forms the full subcategory of the functor category).

\begin{lstlisting}
structure cat :=
{α : Type*}
(β : α → Type*)

instance : category cat :=
{ hom := λ W₀ W₁, nat_trans (polynomial_endofunctor W₀.β) (polynomial_endofunctor W₁.β),
  id := λ _, nat_trans.id _,
  comp := λ _ _ _, nat_trans.vcomp }\end{lstlisting}

We supply some nice instances to lean so that we can write out basic
polynomials

\begin{lstlisting}
/-- The endofunctor `Σ (x : γ), X ^ (fin n) ≃ γ X ^ n ` -/
@[simp] def monomial (γ : Type u₀) (n : ℕ) : cat := ⟨ λ x : γ, ulift (fin n) ⟩

/-- The identity endofunctor as a W_type, `X ≃ punit X ^ 1` -/
@[simp] def X : cat := monomial punit 1

/-- The polynomial endofunctor taking anything to `pempty`,
since `pempty ≃ pempty X ^ 0` -/
@[simps] instance : has_zero cat := { zero := monomial pempty 0 }

/-- The polynomial endofunctor taking anything to `punit`,
since `punit ≃ punit X ^ 0` -/
@[simps] instance : has_one cat := { one := monomial punit 0 }

/-- The constant functor going to a type `γ` is a polynomial
`γ = Σ (a : γ) 1 = Σ (a : γ) X ^ pempty ` -/
instance : has_coe (Type u₀) cat.{u₀ u₀} := { coe := λ γ, monomial γ 0 }

/-- The sum of two polynomial endofunctors
`Σ (a : α₀) X^(β a) + Σ (a : α₁) X^(β₁ a) ≃ Σ (a : α₀ ⊕ α₁) X^((β₀ ⊕ β₁) a)` -/
@[simps] def addition : cat.{u₁ u₀} → cat.{u₁ u₀} → cat.{u₁ u₀} :=
λ W₀ W₁, ⟨ sum.elim W₀.β W₁.β ⟩

@[simps] instance : has_add cat := { add := addition } \end{lstlisting}

With the above we can enjoy easily writing something complicated like
\[ \ga_{5} X^{5} + \ga_{3} X^{2} + X + \ga_{0} + 1\]
for any types $\ga_{5}$, $\ga_{3}$ and $\ga_{0}$ and obtain
their corresponding polynomial endofunctors.
Now it is easy to state the way in which the polynomial endofunctors
we produced in the theory are naturally isomorphic to what we expect.

\begin{lstlisting}
/-- The polynomial endofunctor of the `W_type` for `ℕ` is `1 + X` (a.k.a the maybe monad) -/
def cat_nat_β_eq_one_add_X : cat.mk nat_β ≅ 1 + X := sorry

/-- The polynomial endofunctor for the `W_type` for `list γ` is `1 + γ X` -/
def cat_list_β_eq_one_add_type (γ : Type u₁) : cat.mk (list_β γ) ≅ 1 + monomial γ 1 := sorry \end{lstlisting}

To prove the above, we make the obvious lemma:
if $\al_{0}$ and $\al_{1}$ are equivalent and
$\be_{0} : \al_{0} \to \texttt{Type}$ and $\be_{1} : \al_{1} \to \texttt{Type}$
are equivalent (along the equivalence between $\al_{0}$ and $\al_{1}$),
then the W-types generated by each of them are isomorphic
(i.e. their polynomial endofunctors are naturally isomorphic).
We make use of the extensionality principle
\texttt{nat\_iso.of\_components} for natural isomorphisms:

\begin{lstlisting}
/-- Two W_types are isomorphic if their endofunctors are isomorphic -/
def iso_of_iso {W₀ W₁ : cat} (endo_iso : polynomial_endofunctor W₀.β ≅ polynomial_endofunctor W₁.β) :
  W₀ ≅ W₁ :=
{ hom := endo_iso.hom,
  inv := endo_iso.inv,
  hom_inv_id' := endo_iso.hom_inv_id,
  inv_hom_id' := endo_iso.inv_hom_id }.

/-- Two W_types are isomorphic if their defining types are equivalent -/
def iso_of_equiv {W₀ W₁ : cat} (hα : W₀.α ≃ W₁.α) (hβ : ∀ a : W₀.α, W₀.β a ≃ W₁.β (hα.to_fun a)) :
  W₀ ≅ W₁ :=
iso_of_iso (nat_iso.of_components _ _ ) -- a lot of simp lemmas \end{lstlisting}

The isomorphisms \texttt{cat.mk nat\_$\be \iso $ 1 + X} and
\texttt{cat.mk (list\_$\be$ $\ga$) $\iso$ 1 + monomial $\ga$ 1}
follow, given some equivalences between the obvious types.

\section{Further work}

I am in the process of pushing the above to mathlib.
In my next project I might work on the categorical generalisation of
polynomial endofunctors, and try to show that they do in fact coincide
with sums of exponentials (as we took the definition to be here) in the case  where the category is \texttt{Type}.
Another missing aspect of the above is families of inductive types,
which could be an interesting direction to explore.

\bibliography{refs}{}
\bibliographystyle{abbrv}

\end{document}
